// src/jit.rs
use dynasmrt::{dynasm, DynasmApi, DynasmLabelApi};
use dynasmrt::x64::Assembler;
use im::HashMap;
use crate::ast::*;
use crate::instr::*;
use crate::compiler::compile_to_instrs;
use std::collections::HashMap as StdHashMap;

pub fn compile_to_jit(
    program: &Program, 
    ops: &mut Assembler, 
    defines: &mut HashMap<String, i32>, 
    fun_ctx: &crate::compiler::FunContext
) {
    let mut label_map: StdHashMap<String, dynasmrt::DynamicLabel> = StdHashMap::new();
    
    // Pre-create labels for all functions
    for defn in &program.defns {
        let fun_label = ops.new_dynamic_label();
        label_map.insert(format!("fun_{}", defn.name), fun_label);
    }
    
    // Pre-create error handler labels
    let snek_print = ops.new_dynamic_label();
    let error_overflow = ops.new_dynamic_label();
    let error_invalid_arg = ops.new_dynamic_label();
    label_map.insert("_snek_print".to_string(), snek_print);
    label_map.insert("error_overflow".to_string(), error_overflow);
    label_map.insert("error_invalid_argument".to_string(), error_invalid_arg);
    
    // Compile all function definitions
    for defn in &program.defns {
        let fun_label = label_map[&format!("fun_{}", defn.name)];
        
        dynasm!(ops
            ; .arch x64
            ; =>fun_label
            ; push rbp
            ; mov rbp, rsp
        );
        
        let n_args = defn.params.len() as i32;
        let mut env = HashMap::new();
        
        for (i, param) in defn.params.iter().enumerate() {
            let offset = if i < 6 {
                -8 * ((i as i32) + 1)
            } else {
                16 + 8 * ((n_args - 1) - (i as i32))
            };
            env = env.update(param.clone(), offset);
        }
        
        let (instrs, min_offset) = compile_to_instrs(
            &defn.body,
            -8 * ((n_args.min(6)) + 1),
            &env,
            defines,
            fun_ctx,
            false,
            &None,
        );
        
        let stack_space = if min_offset < 0 {
            let needed = (-min_offset) as i32;
            ((needed + 15) / 16) * 16
        } else {
            16
        };
        
        dynasm!(ops
            ; .arch x64
            ; sub rsp, stack_space
        );
        
        // Copy first 6 args from registers to stack
        let arg_regs = [Reg::RDI, Reg::RSI, Reg::RDX, Reg::RCX, Reg::R8, Reg::R9];
        for (i, _param) in defn.params.iter().enumerate() {
            if i < 6 {
                let offset = -8 * ((i as i32) + 1);
                let save_instr = Instr::IMov(
                    Val::RegOffset(Reg::RBP, offset), 
                    Val::Reg(arg_regs[i])
                );
                instr_to_dynasm(&save_instr, ops, &label_map);
            }
        }
        
        // Emit function body instructions
        for instr in &instrs {
            instr_to_dynasm(instr, ops, &label_map);
        }
        
        dynasm!(ops
            ; .arch x64
            ; mov rsp, rbp
            ; pop rbp
            ; ret
        );
    }
    
    // Compile main - need prologue first!
    dynasm!(ops
        ; .arch x64
        ; push rbp
        ; mov rbp, rsp
    );
    
    let (instrs, min_offset) = compile_to_instrs(
        &program.main, 
        -8, 
        &HashMap::new(), 
        defines, 
        fun_ctx, 
        true, 
        &None
    );
    
    // Allocate stack space for main
    let needed = -min_offset;
    let stack_space = if needed <= 0 { 0 } else { ((needed + 15) / 16) * 16 };
    if stack_space > 0 {
        dynasm!(ops
            ; .arch x64
            ; sub rsp, stack_space as i32
        );
    }

    // DEBUG: Print all instructions that will be JIT compiled
    eprintln!("=== JIT Instructions ===");
    for instr in &instrs {
        eprintln!("{}", crate::instr::instr_to_str(instr));
    }
    eprintln!("========================\n");
    // First pass: collect all labels from main instructions
    for instr in &instrs {
        if let Instr::ILabel(label_name) = instr {
            if !label_map.contains_key(label_name) {
                label_map.insert(label_name.clone(), ops.new_dynamic_label());
            }
        }
        match instr {
            Instr::IJmp(label) | Instr::IJe(label) | Instr::IJne(label) | Instr::IJo(label) => {
                if !label_map.contains_key(label) {
                    label_map.insert(label.clone(), ops.new_dynamic_label());
                }
            }
            _ => {}
        }
    }
    
    // Second pass: emit main instructions
    for instr in &instrs {
        instr_to_dynasm(instr, ops, &label_map);
    }
    
    // Main epilogue
    dynasm!(ops
        ; .arch x64
        ; mov rsp, rbp
        ; pop rbp
        ; ret
    );
    
    let snek_error_addr = crate::snek_error as *const () as i64;
    let snek_print_addr = crate::_snek_print as *const () as i64;

    dynasm!(ops
        ; .arch x64
        ; =>snek_print
        ; push rbp
        ; mov rbp, rsp
        ; mov rax, QWORD snek_print_addr as _
        ; call rax
        ; pop rbp
        ; ret
    );
    
    dynasm!(ops
        ; .arch x64
        ; =>error_overflow
        ; mov rdi, 1
        ; mov rax, QWORD snek_error_addr as _
        ; call rax
        ; ret
        ; =>error_invalid_arg
        ; mov rdi, 2
        ; mov rax, QWORD snek_error_addr as _
        ; call rax
        ; ret
    );
}
pub fn instr_to_dynasm(instr: &Instr, ops: &mut Assembler, label_map: &StdHashMap<String, dynasmrt::DynamicLabel>) {
    // Helper macros for signed RBP offsets
    macro_rules! load_rbp {
        ($reg:ident, $offset:expr) => {
            if *$offset < 0 {
                dynasm!(ops; .arch x64; mov $reg, [rbp - (-*$offset)]);
            } else {
                dynasm!(ops; .arch x64; mov $reg, [rbp + *$offset]);
            }
        };
    }
    macro_rules! store_rbp {
        ($offset:expr, $reg:ident) => {
            if *$offset < 0 {
                dynasm!(ops; .arch x64; mov [rbp - (-*$offset)], $reg);
            } else {
                dynasm!(ops; .arch x64; mov [rbp + *$offset], $reg);
            }
        };
    }

    match instr {
        Instr::IMov(dest, src) => {
            match (dest, src) {
                // Immediate to register
                (Val::Reg(Reg::RAX), Val::Imm(n)) => dynasm!(ops; .arch x64; mov rax, QWORD *n as i64),
                (Val::Reg(Reg::RCX), Val::Imm(n)) => dynasm!(ops; .arch x64; mov rcx, QWORD *n as i64),
                (Val::Reg(Reg::RDI), Val::Imm(n)) => dynasm!(ops; .arch x64; mov rdi, QWORD *n as i64),

                // Register to register
                (Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; mov rax, rcx),
                (Val::Reg(Reg::RAX), Val::Reg(Reg::RDI)) => dynasm!(ops; .arch x64; mov rax, rdi),
                (Val::Reg(Reg::RCX), Val::Reg(Reg::RAX)) => dynasm!(ops; .arch x64; mov rcx, rax),
                (Val::Reg(Reg::RDI), Val::Reg(Reg::RAX)) => dynasm!(ops; .arch x64; mov rdi, rax),

                // RBP-relative loads
                (Val::Reg(Reg::RAX), Val::RegOffset(Reg::RBP, offset)) => load_rbp!(rax, offset),
                (Val::Reg(Reg::RCX), Val::RegOffset(Reg::RBP, offset)) => load_rbp!(rcx, offset),
                (Val::Reg(Reg::RDI), Val::RegOffset(Reg::RBP, offset)) => load_rbp!(rdi, offset),
                (Val::Reg(Reg::RSI), Val::RegOffset(Reg::RBP, offset)) => load_rbp!(rsi, offset),
                (Val::Reg(Reg::RDX), Val::RegOffset(Reg::RBP, offset)) => load_rbp!(rdx, offset),
                (Val::Reg(Reg::R8),  Val::RegOffset(Reg::RBP, offset)) => load_rbp!(r8,  offset),
                (Val::Reg(Reg::R9),  Val::RegOffset(Reg::RBP, offset)) => load_rbp!(r9,  offset),

                // RBP-relative stores
                (Val::RegOffset(Reg::RBP, offset), Val::Reg(Reg::RAX)) => store_rbp!(offset, rax),
                (Val::RegOffset(Reg::RBP, offset), Val::Reg(Reg::RDI)) => store_rbp!(offset, rdi),
                (Val::RegOffset(Reg::RBP, offset), Val::Reg(Reg::RSI)) => store_rbp!(offset, rsi),
                (Val::RegOffset(Reg::RBP, offset), Val::Reg(Reg::RDX)) => store_rbp!(offset, rdx),
                (Val::RegOffset(Reg::RBP, offset), Val::Reg(Reg::RCX)) => store_rbp!(offset, rcx),
                (Val::RegOffset(Reg::RBP, offset), Val::Reg(Reg::R8))  => store_rbp!(offset, r8),
                (Val::RegOffset(Reg::RBP, offset), Val::Reg(Reg::R9))  => store_rbp!(offset, r9),

                // Heap (R15-relative)
                (Val::Reg(Reg::RAX), Val::RegOffset(Reg::R15, offset)) =>
                    dynasm!(ops; .arch x64; mov rax, [r15 + *offset]),
                (Val::RegOffset(Reg::R15, offset), Val::Reg(Reg::RAX)) =>
                    dynasm!(ops; .arch x64; mov [r15 + *offset], rax),

                _ => panic!("Unsupported mov pattern in JIT: {:?} <- {:?}", dest, src),
            }
        }

        // === Binary arithmetic ===
        Instr::IAdd(dest, src) => match (dest, src) {
            (Val::Reg(Reg::RAX), Val::Imm(n)) => dynasm!(ops; .arch x64; add rax, *n as i32),
            (Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; add rax, rcx),
            (Val::Reg(Reg::RAX), Val::RegOffset(Reg::RBP, offset)) => {
                if *offset < 0 { dynasm!(ops; .arch x64; add rax, [rbp - (-*offset)]); }
                else { dynasm!(ops; .arch x64; add rax, [rbp + *offset]); }
            }
            (Val::Reg(Reg::RSP), Val::Imm(n)) => dynasm!(ops; .arch x64; add rsp, *n as i32),
            _ => panic!("Unsupported add pattern in JIT: {:?} += {:?}", dest, src),
        },

        Instr::ISub(dest, src) => match (dest, src) {
            (Val::Reg(Reg::RAX), Val::Imm(n)) => dynasm!(ops; .arch x64; sub rax, *n as i32),
            (Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; sub rax, rcx),
            (Val::Reg(Reg::RAX), Val::RegOffset(Reg::RBP, offset)) => {
                if *offset < 0 { dynasm!(ops; .arch x64; sub rax, [rbp - (-*offset)]); }
                else { dynasm!(ops; .arch x64; sub rax, [rbp + *offset]); }
            }
            _ => panic!("Unsupported sub pattern in JIT: {:?} -= {:?}", dest, src),
        },

        Instr::IMul(dest, src) => match (dest, src) {
            (Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; imul rax, rcx),
            (Val::Reg(Reg::RAX), Val::RegOffset(Reg::RBP, offset)) => {
                if *offset < 0 { dynasm!(ops; .arch x64; imul rax, [rbp - (-*offset)]); }
                else { dynasm!(ops; .arch x64; imul rax, [rbp + *offset]); }
            }
            _ => panic!("Unsupported imul pattern in JIT: {:?} *= {:?}", dest, src),
        },

        // === Comparison and test ===
        Instr::ICmp(dest, src) => match (dest, src) {
            (Val::Reg(Reg::RAX), Val::Imm(n)) => dynasm!(ops; .arch x64; cmp rax, *n as i32),
            (Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; cmp rax, rcx),
            (Val::Reg(Reg::RCX), Val::Reg(Reg::RAX)) => dynasm!(ops; .arch x64; cmp rcx, rax),
            _ => panic!("Unsupported cmp pattern in JIT: {:?} cmp {:?}", dest, src),
        },

        Instr::ITest(dest, src) => match (dest, src) {
            (Val::Reg(Reg::RAX), Val::Imm(n)) => dynasm!(ops; .arch x64; test rax, *n as i32),
            (Val::Reg(Reg::RCX), Val::Imm(n)) => dynasm!(ops; .arch x64; test rcx, *n as i32),
            _ => panic!("Unsupported test pattern in JIT: {:?} test {:?}", dest, src),
        },

        Instr::IOr(dest, src) => match (dest, src) {
            (Val::Reg(Reg::RCX), Val::RegOffset(Reg::RBP, offset)) => {
                if *offset < 0 { dynasm!(ops; .arch x64; or rcx, [rbp - (-*offset)]); }
                else { dynasm!(ops; .arch x64; or rcx, [rbp + *offset]); }
            }
            _ => panic!("Unsupported or pattern in JIT: {:?} | {:?}", dest, src),
        },

        Instr::ISar(dest, src) => match (dest, src) {
            (Val::Reg(Reg::RAX), Val::Imm(n)) => dynasm!(ops; .arch x64; sar rax, *n as i8),
            _ => panic!("Unsupported sar pattern in JIT: {:?} >> {:?}", dest, src),
        },

        // === Conditional moves ===
        Instr::ICMovE(Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; cmove rax, rcx),
        Instr::ICMovNE(Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; cmovne rax, rcx),
        Instr::ICMovG(Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; cmovg rax, rcx),
        Instr::ICMovGE(Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; cmovge rax, rcx),
        Instr::ICMovL(Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; cmovl rax, rcx),
        Instr::ICMovLE(Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; cmovle rax, rcx),

        // === Control flow ===
        Instr::ILabel(label_name) => {
            if let Some(&label) = label_map.get(label_name) {
                dynasm!(ops; .arch x64; =>label);
            }
        }
        Instr::IJmp(label_name) => if let Some(&label) = label_map.get(label_name) {
            dynasm!(ops; .arch x64; jmp =>label);
        },
        Instr::IJe(label_name) => if let Some(&label) = label_map.get(label_name) {
            dynasm!(ops; .arch x64; je =>label);
        },
        Instr::IJne(label_name) => if let Some(&label) = label_map.get(label_name) {
            dynasm!(ops; .arch x64; jne =>label);
        },
        Instr::IJo(label_name) => if let Some(&label) = label_map.get(label_name) {
            dynasm!(ops; .arch x64; jo =>label);
        },

        Instr::ICall(label) => {
            if label == "*rax" {
                dynasm!(ops; .arch x64; call rax);
            } else if let Some(&target_label) = label_map.get(label) {
                dynasm!(ops; .arch x64; call =>target_label);
            } else {
                panic!("Unsupported call target: {}", label);
            }
        }

        Instr::IPush(val) => match val {
            Val::Reg(Reg::RAX) => dynasm!(ops; .arch x64; push rax),
            _ => panic!("Unsupported push: {:?}", val),
        },

        Instr::IRet => dynasm!(ops; .arch x64; ret),
        Instr::IPop(val) => match val {
            Val::Reg(Reg::RAX) => dynasm!(ops; .arch x64; pop rax),
            _ => panic!("Unsupported pop: {:?}", val),
        },
        Instr::IComment(_) => {},


        _ => panic!("Unsupported instruction in JIT: {:?}", instr),
    }
}
