commit 29e0efe6023001195ff20150e9d9001d77059908
Author: AlainZhangStudent <41776644+SirPuddinlot@users.noreply.github.com>
Date:   Mon Nov 17 22:58:18 2025 -0800

    deduplicated logic in jit/repl

diff --git a/Makefile b/Makefile
index 5501dc6..89f4d74 100644
--- a/Makefile
+++ b/Makefile
@@ -38,7 +38,10 @@ test/%.jitt: test/%.snek src/main.rs
 
 # Both JIT execute and generate assembly (debugging)
 test/%.debug: test/%.snek src/main.rs
-	cargo run --target x86_64-apple-darwin -- -g $< 
+	cargo run --target x86_64-apple-darwin -- -g $< test/$*.s $(filter-out $@,$(MAKECMDGOALS))
+
+test/%.debugt: test/%.snek src/main.rs
+	cargo run --target x86_64-apple-darwin -- -g $< test/$*.s $(filter-out $@,$(MAKECMDGOALS))
 
 clean:
 	rm -f test/*.s test/*.run runtime/*.o runtime/*.a
diff --git a/src/jit.rs b/src/jit.rs
index 3127a90..8c2836d 100644
--- a/src/jit.rs
+++ b/src/jit.rs
@@ -7,13 +7,13 @@ use crate::instr::*;
 use crate::compiler::compile_to_instrs;
 use std::collections::HashMap as StdHashMap;
 use crate::compiler::get_input_heap_offset;
-// In jit.rs - Simplified error handlers since catch_unwind handles everything
 
-fn compile_error_handlers_for_repl(
+/// Compile error handlers for JIT execution
+/// This includes print handler and runtime error handlers (overflow, invalid argument, bad cast)
+pub fn compile_error_handlers(
     ops: &mut Assembler,
     label_map: &StdHashMap<String, dynasmrt::DynamicLabel>,
-) 
-{
+) {
     let snek_error_addr = crate::helpers::snek_error as *const () as i64;
     let snek_print_addr = crate::helpers::_snek_print as *const () as i64;
     
@@ -22,7 +22,7 @@ fn compile_error_handlers_for_repl(
     let error_invalid_arg = label_map["error_invalid_argument"];
     let error_bad_cast = label_map["error_bad_cast"];
 
-    // Print handler
+    // Print handler - called via 'call' instruction, so 'ret' is correct
     dynasm!(ops
         ; .arch x64
         ; =>snek_print
@@ -34,19 +34,17 @@ fn compile_error_handlers_for_repl(
         ; ret
     );
     
-    // Error handlers - jumped to from error conditions
-    // Call snek_error (which uses catch_unwind internally)
-    // Then restore stack and return with error sentinel value
+    // Error handlers - jumped to via 'jo', 'jne', so must restore stack frame
     dynasm!(ops
         ; .arch x64
         ; =>error_overflow
         ; mov rdi, 1
         ; mov rax, QWORD snek_error_addr as _
         ; call rax
-        ; mov rax, 0  // Return sentinel value
-        ; mov rsp, rbp
-        ; pop rbp
-        ; ret
+        ; mov rax, 0          // Return sentinel value
+        ; mov rsp, rbp        // Restore stack pointer
+        ; pop rbp             // Restore base pointer
+        ; ret                 // Return to caller
         
         ; =>error_invalid_arg
         ; mov rdi, 2
@@ -155,8 +153,8 @@ pub fn compile_functions_only(
         );
     }
     
-    // Compile error handlers
-    compile_error_handlers_for_repl(ops, label_map);
+    // Compile error handlers (now using shared function)
+    compile_error_handlers(ops, label_map);
 }
 
 pub fn compile_to_jit(
@@ -182,10 +180,9 @@ pub fn compile_to_jit(
     label_map.insert("error_overflow".to_string(), error_overflow);
     label_map.insert("error_invalid_argument".to_string(), error_invalid_arg);
     label_map.insert("error_bad_cast".to_string(), error_bad_cast);
-    // Compile all function definitions with stack-based calling convention
+    
+    // Compile all function definitions
     for defn in &program.defns {
-       //println!("Function {} body type: {}", defn.name, std::any::type_name_of_val(&defn.body));
-
         let fun_label = label_map[&format!("fun_{}", defn.name)];
         
         dynasm!(ops
@@ -195,18 +192,12 @@ pub fn compile_to_jit(
             ; mov rbp, rsp
         );
         
-        // Build environment: parameters are on caller's stack at [rbp+16], [rbp+24], etc.
         let mut env = HashMap::new();
         for (i, param) in defn.params.iter().enumerate() {
             let offset = 16 + (i as i32 * 8);
             env = env.update(param.clone(), offset);
         }
 
-        // println!("=== Compiling function: {} ===", defn.name);
-        // println!("Parameters: {:?}", defn.params);
-        // println!("Body: {:?}", defn.body);
-
-        // Compile function body
         let (instrs, min_offset) = compile_to_instrs(
             &defn.body,
             -8,
@@ -216,13 +207,7 @@ pub fn compile_to_jit(
             false,
             &None,
         );
-
-        // println!("=== Instructions for {} body ===", defn.name);
-        // for instr in &instrs {
-        //     println!("{:?}", instr);
-        // }
         
-        // Allocate stack space for local variables if needed
         if min_offset < 0 {
             let needed = -min_offset;
             let stack_space = ((needed + 15) / 16) * 16;
@@ -232,7 +217,6 @@ pub fn compile_to_jit(
             );
         }
         
-        // Collect labels used in function body
         for instr in &instrs {
             if let Instr::ILabel(label_name) = instr {
                 if !label_map.contains_key(label_name) {
@@ -249,7 +233,6 @@ pub fn compile_to_jit(
             }
         }
         
-        // Emit function body instructions
         for instr in &instrs {
             instr_to_dynasm(instr, ops, &label_map);
         }
@@ -261,21 +244,6 @@ pub fn compile_to_jit(
             ; ret
         );
     }
-    
-    // Debug main instructions
-    let (main_instrs, min_offset) = compile_to_instrs(
-        &program.main,
-        -8,
-        &HashMap::new(),
-        defines,
-        fun_ctx,
-        true,
-        &None
-    );
-    // println!("=== Instructions for main body ===");
-    // for instr in &main_instrs {
-    //     println!("{:?}", instr);
-    // }
 
     // Compile main
     dynasm!(ops
@@ -284,7 +252,6 @@ pub fn compile_to_jit(
         ; mov rbp, rsp
     );
     
-    // Store input to heap at the beginning (R15 points to heap)
     let input_heap_offset = get_input_heap_offset();
     dynasm!(ops
         ; .arch x64
@@ -301,10 +268,8 @@ pub fn compile_to_jit(
         &None
     );
     
-    // Allocate stack space for local variables in main if needed
-    // Only allocate if we've actually used stack slots (min_offset < -8 means we used [rbp-16] or lower)
     if min_offset <= -16 {
-        let needed = -min_offset - 8;  // Subtract 8 because -8 is just the starting point
+        let needed = -min_offset - 8;
         let stack_space = ((needed + 15) / 16) * 16;
         dynasm!(ops
             ; .arch x64
@@ -312,7 +277,7 @@ pub fn compile_to_jit(
         );
     }
 
-    // First pass: collect all labels from main instructions
+    // Collect all labels from main instructions
     for instr in &instrs {
         if let Instr::ILabel(label_name) = instr {
             if !label_map.contains_key(label_name) {
@@ -329,7 +294,7 @@ pub fn compile_to_jit(
         }
     }
     
-    // Second pass: emit main instructions
+    // Emit main instructions
     for instr in &instrs {
         instr_to_dynasm(instr, ops, &label_map);
     }
@@ -342,39 +307,8 @@ pub fn compile_to_jit(
         ; ret
     );
     
-    // Error handlers
-    let snek_error_addr = crate::snek_error as *const () as i64;
-    let snek_print_addr = crate::_snek_print as *const () as i64;
-
-    dynasm!(ops
-        ; .arch x64
-        ; =>snek_print
-        ; push rbp
-        ; mov rbp, rsp
-        ; mov rax, QWORD snek_print_addr as _
-        ; call rax
-        ; pop rbp
-        ; ret
-    );
-    
-    dynasm!(ops
-        ; .arch x64
-        ; =>error_overflow
-        ; mov rdi, 1
-        ; mov rax, QWORD snek_error_addr as _
-        ; call rax
-        ; ret
-        ; =>error_invalid_arg
-        ; mov rdi, 2
-        ; mov rax, QWORD snek_error_addr as _
-        ; call rax
-        ; ret
-        ; =>error_bad_cast
-        ; mov rdi, 3
-        ; mov rax, QWORD snek_error_addr as _
-        ; call rax
-        ; ret
-    );
+    // Compile error handlers (now using shared function)
+    compile_error_handlers(ops, &label_map);
 }
 
 pub fn instr_to_dynasm(instr: &Instr, ops: &mut Assembler, label_map: &StdHashMap<String, dynasmrt::DynamicLabel>) {
@@ -449,11 +383,9 @@ pub fn instr_to_dynasm(instr: &Instr, ops: &mut Assembler, label_map: &StdHashMa
         };
     }
     
-    // println!("JIT emitting: {:?}", instr);
     match instr {
         Instr::IMov(dest, src) => {
             match (dest, src) {
-                // Immediate to register
                 (Val::Reg(Reg::RAX), Val::Imm(n)) => dynasm!(ops; .arch x64; mov rax, QWORD *n as i64),
                 (Val::Reg(Reg::RCX), Val::Imm(n)) => dynasm!(ops; .arch x64; mov rcx, QWORD *n as i64),
                 (Val::Reg(Reg::RDI), Val::Imm(n)) => dynasm!(ops; .arch x64; mov rdi, QWORD *n as i64),
@@ -462,7 +394,6 @@ pub fn instr_to_dynasm(instr: &Instr, ops: &mut Assembler, label_map: &StdHashMa
                 (Val::Reg(Reg::R8), Val::Imm(n)) => dynasm!(ops; .arch x64; mov r8, QWORD *n as i64),
                 (Val::Reg(Reg::R9), Val::Imm(n)) => dynasm!(ops; .arch x64; mov r9, QWORD *n as i64),
 
-                // Register to register
                 (Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; mov rax, rcx),
                 (Val::Reg(Reg::RAX), Val::Reg(Reg::RDI)) => dynasm!(ops; .arch x64; mov rax, rdi),
                 (Val::Reg(Reg::RCX), Val::Reg(Reg::RAX)) => dynasm!(ops; .arch x64; mov rcx, rax),
@@ -472,11 +403,7 @@ pub fn instr_to_dynasm(instr: &Instr, ops: &mut Assembler, label_map: &StdHashMa
                 (Val::Reg(Reg::R8), Val::Reg(Reg::RAX)) => dynasm!(ops; .arch x64; mov r8, rax),
                 (Val::Reg(Reg::R9), Val::Reg(Reg::RAX)) => dynasm!(ops; .arch x64; mov r9, rax),
 
-                // RBP-relative loads (supports positive offsets now!)
-                (Val::Reg(Reg::RAX), Val::RegOffset(Reg::RBP, offset)) => {
-                    // eprintln!("DEBUG: Loading from RBP+{}, offset value = {}\n ==========", offset, offset);
-                    load_rbp!(rax, offset);
-                },
+                (Val::Reg(Reg::RAX), Val::RegOffset(Reg::RBP, offset)) => load_rbp!(rax, offset),
                 (Val::Reg(Reg::RCX), Val::RegOffset(Reg::RBP, offset)) => load_rbp!(rcx, offset),
                 (Val::Reg(Reg::RDI), Val::RegOffset(Reg::RBP, offset)) => load_rbp!(rdi, offset),
                 (Val::Reg(Reg::RSI), Val::RegOffset(Reg::RBP, offset)) => load_rbp!(rsi, offset),
@@ -484,7 +411,6 @@ pub fn instr_to_dynasm(instr: &Instr, ops: &mut Assembler, label_map: &StdHashMa
                 (Val::Reg(Reg::R8),  Val::RegOffset(Reg::RBP, offset)) => load_rbp!(r8,  offset),
                 (Val::Reg(Reg::R9),  Val::RegOffset(Reg::RBP, offset)) => load_rbp!(r9,  offset),
 
-                // RBP-relative stores (supports positive offsets now!)
                 (Val::RegOffset(Reg::RBP, offset), Val::Reg(Reg::RAX)) => store_rbp!(offset, rax),
                 (Val::RegOffset(Reg::RBP, offset), Val::Reg(Reg::RDI)) => store_rbp!(offset, rdi),
                 (Val::RegOffset(Reg::RBP, offset), Val::Reg(Reg::RSI)) => store_rbp!(offset, rsi),
@@ -493,7 +419,6 @@ pub fn instr_to_dynasm(instr: &Instr, ops: &mut Assembler, label_map: &StdHashMa
                 (Val::RegOffset(Reg::RBP, offset), Val::Reg(Reg::R8))  => store_rbp!(offset, r8),
                 (Val::RegOffset(Reg::RBP, offset), Val::Reg(Reg::R9))  => store_rbp!(offset, r9),
 
-                // Heap (R15-relative)
                 (Val::Reg(Reg::RAX), Val::RegOffset(Reg::R15, offset)) =>
                     dynasm!(ops; .arch x64; mov rax, [r15 + *offset]),
                 (Val::RegOffset(Reg::R15, offset), Val::Reg(Reg::RAX)) =>
@@ -505,7 +430,6 @@ pub fn instr_to_dynasm(instr: &Instr, ops: &mut Assembler, label_map: &StdHashMa
             }
         }
 
-        // === Binary arithmetic ===
         Instr::IAdd(dest, src) => match (dest, src) {
             (Val::Reg(Reg::RAX), Val::Imm(n)) => dynasm!(ops; .arch x64; add rax, *n as i32),
             (Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; add rax, rcx),
@@ -528,7 +452,6 @@ pub fn instr_to_dynasm(instr: &Instr, ops: &mut Assembler, label_map: &StdHashMa
             _ => panic!("Unsupported imul pattern in JIT: {:?} *= {:?}", dest, src),
         },
 
-        // === Comparison and test ===
         Instr::ICmp(dest, src) => match (dest, src) {
             (Val::Reg(Reg::RAX), Val::Imm(n)) => dynasm!(ops; .arch x64; cmp rax, *n as i32),
             (Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; cmp rax, rcx),
@@ -553,7 +476,6 @@ pub fn instr_to_dynasm(instr: &Instr, ops: &mut Assembler, label_map: &StdHashMa
             _ => panic!("Unsupported sar pattern in JIT: {:?} >> {:?}", dest, src),
         },
 
-        // === Conditional moves ===
         Instr::ICMovE(Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; cmove rax, rcx),
         Instr::ICMovNE(Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; cmovne rax, rcx),
         Instr::ICMovG(Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; cmovg rax, rcx),
@@ -561,7 +483,6 @@ pub fn instr_to_dynasm(instr: &Instr, ops: &mut Assembler, label_map: &StdHashMa
         Instr::ICMovL(Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; cmovl rax, rcx),
         Instr::ICMovLE(Val::Reg(Reg::RAX), Val::Reg(Reg::RCX)) => dynasm!(ops; .arch x64; cmovle rax, rcx),
 
-        // === Control flow ===
         Instr::ILabel(label_name) => {
             if let Some(&label) = label_map.get(label_name) {
                 dynasm!(ops; .arch x64; =>label);
@@ -584,14 +505,12 @@ pub fn instr_to_dynasm(instr: &Instr, ops: &mut Assembler, label_map: &StdHashMa
             if label == "*rax" {
                 dynasm!(ops; .arch x64; call rax);
             } else if label.starts_with("fun_") {
-                // Handle function calls specifically
                 if let Some(&target_label) = label_map.get(label) {
                     dynasm!(ops; .arch x64; call =>target_label);
                 } else {
                     panic!("Unknown function call: {}", label);
                 }
             } else if let Some(&target_label) = label_map.get(label) {
-                // Other labels (like error handlers)
                 dynasm!(ops; .arch x64; call =>target_label);
             } else {
                 panic!("Unsupported call target: {}", label);
@@ -617,5 +536,4 @@ pub fn instr_to_dynasm(instr: &Instr, ops: &mut Assembler, label_map: &StdHashMa
 
         _ => panic!("Unsupported instruction in JIT: {:?}", instr),
     }
-}
-
+}
\ No newline at end of file
diff --git a/src/main.rs b/src/main.rs
index 1bad839..4249298 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -90,19 +90,27 @@ fn main() -> std::io::Result<()> {
     let typecheck_mode = flag.starts_with("-t");
     
     if typecheck_mode {
-        let input_type = match flag.as_str() {
-            "-t" | "-tc" => {
-                // No input provided, input has type Any
-                None
-            }
-            "-te" | "-tg" => {
-                // Parse input to determine type
-                let input_str = if args.len() > 3 { &args[3] } else { "false" };
-                let input = parse_input(input_str);
-                Some(if input & 1 == 0 { Type::Num } else { Type::Bool })
-            }
-            _ => None
-        };
+        if typecheck_mode {
+            let input_type = match flag.as_str() {
+                "-t" | "-tc" => {
+                    // No input provided, input has type Any
+                    None
+                }
+                "-te" => {
+                    // For -te: input is at args[3]
+                    let input_str = if args.len() > 3 { &args[3] } else { "false" };
+                    let input = parse_input(input_str);
+                    Some(if input & 1 == 0 { Type::Num } else { Type::Bool })
+                }
+                "-tg" => {
+                    // For -tg: format is -tg <prog>.snek <prog>.s <input>
+                    // So input is at args[4]
+                    let input_str = if args.len() > 4 { &args[4] } else { "false" };
+                    let input = parse_input(input_str);
+                    Some(if input & 1 == 0 { Type::Num } else { Type::Bool })
+                }
+                _ => None
+            };
         
         // Run typechecker
         match typecheck_program(&prog, input_type) {
@@ -119,6 +127,7 @@ fn main() -> std::io::Result<()> {
                 std::process::exit(1);
             }
         }
+       }
     }
     
     match flag.as_str() {
@@ -232,24 +241,31 @@ extern _snek_print
             print_result(result_val);
         }
         "-g" | "-tg" => {
-            // Both: JIT execution and AOT compilation
-            let input_str = if args.len() > 3 { &args[3] } else { "false" };
+            // Both: JIT execution and write assembly to file
+            // Format: -g/-tg <prog>.snek <prog>.s <input>
+            if args.len() < 4 {
+                eprintln!("Error: output file required for -g/-tg");
+                std::process::exit(1);
+            }
+
+            let out_name = &args[3];
+            let input_str = if args.len() > 4 { &args[4] } else { "false" };
             let input = parse_input(input_str);
-            
+
             // === JIT COMPILATION AND EXECUTION ===
             let mut __ops__ = dynasmrt::x64::Assembler::new().unwrap();
             let heap: Vec<i64> = vec![0; 128 * 1024];
             let heap_ptr = heap.as_ptr() as i64;
-            
+
             let mut __fun_ctx__ = FunContext::new(&prog.defns);
             let mut __label_map__ = std::collections::HashMap::new();
-            
+
             // Compile function definitions and error handlers
             compile_functions_only(&prog, &mut __ops__, &mut HashMap::new(), &mut __fun_ctx__, &mut __label_map__);
-            
+
             // Capture the offset - this is where main starts
             let start = __ops__.offset();
-            
+
             // Set up heap pointer and function prologue
             dynasm!(__ops__
                 ; .arch x64
@@ -257,14 +273,14 @@ extern _snek_print
                 ; mov rbp, rsp
                 ; mov r15, QWORD heap_ptr as _
             );
-            
+
             // Store input to heap
             let input_heap_offset = get_input_heap_offset();
             dynasm!(__ops__
                 ; .arch x64
                 ; mov [r15 + input_heap_offset], rdi
             );
-            
+
             // Compile main expression
             let (main_instrs, min_offset) = crate::compiler::compile_to_instrs(
                 &prog.main,
@@ -275,14 +291,14 @@ extern _snek_print
                 true,
                 &None,
             );
-            
+
             // Allocate stack space if needed
             if min_offset <= -16 {
                 let needed = -min_offset - 8;
                 let stack_space = ((needed + 15) / 16) * 16;
                 dynasm!(__ops__; .arch x64; sub rsp, stack_space as i32);
             }
-            
+
             // Pre-create labels for main
             for instr in &main_instrs {
                 if let Instr::ILabel(label_name) = instr {
@@ -299,12 +315,12 @@ extern _snek_print
                     _ => {}
                 }
             }
-            
+
             // Emit main instructions
             for instr in &main_instrs {
                 crate::jit::instr_to_dynasm(instr, &mut __ops__, &__label_map__);
             }
-            
+
             // Main epilogue
             dynasm!(__ops__
                 ; .arch x64
@@ -312,25 +328,34 @@ extern _snek_print
                 ; pop rbp
                 ; ret
             );
-            
+
             // Execute JIT
             let buf = __ops__.finalize().unwrap();
             let jitted_fn: extern "C" fn(i64) -> i64 = unsafe { std::mem::transmute(buf.ptr(start)) };
             let result_val = jitted_fn(input);
-            
+
             std::mem::forget(heap);
-            
+
             println!("JIT Result: ");
             print_result(result_val);
-            
+
             // === AOT COMPILATION OUTPUT ===
-            println!("\n=== Generated Assembly ===");
             let result = compile(&prog);
             let asm_program = format!(
-                "section .text\nglobal our_code_starts_here\nextern snek_error\nextern _snek_print\n\n{}",
+                "section .text
+global our_code_starts_here
+extern snek_error
+extern _snek_print
+
+{}",
                 result
             );
+            println!("\n=== Generated Assembly ===");
             println!("{}", asm_program);
+            let mut out_file = File::create(out_name)?;
+            out_file.write_all(asm_program.as_bytes())?;
+
+            println!("Assembly written to: {}", out_name);
         }
         _ => {
             eprintln!("Error: Unknown flag '{}'", flag);
diff --git a/src/repl.rs b/src/repl.rs
index bae3f36..e25aa14 100644
--- a/src/repl.rs
+++ b/src/repl.rs
@@ -49,53 +49,8 @@ pub fn run_repl(typecheck: bool) -> io::Result<()> {
     label_map.insert("error_invalid_argument".to_string(), error_invalid_arg);
     label_map.insert("error_bad_cast".to_string(), error_bad_cast);
     
-    // Compile error handlers once at the start
-    let snek_error_addr = crate::helpers::snek_error as *const () as i64;
-    let snek_print_addr = crate::helpers::_snek_print as *const () as i64;
-
-    // Print handler - this is CALLED so just ret is fine
-    dynasm!(ops
-        ; .arch x64
-        ; =>snek_print
-        ; push rbp
-        ; mov rbp, rsp
-        ; mov rax, QWORD snek_print_addr as _
-        ; call rax
-        ; pop rbp
-        ; ret
-    );
-    
-    // Error handlers - these are JUMPED TO (not called)
-    // So they need to restore the stack frame before returning
-    dynasm!(ops
-        ; .arch x64
-        ; =>error_overflow
-        ; mov rdi, 1
-        ; mov rax, QWORD snek_error_addr as _
-        ; call rax
-        ; mov rax, 0          // Set sentinel return value
-        ; mov rsp, rbp        // Restore stack pointer
-        ; pop rbp             // Restore base pointer
-        ; ret                 // Return to caller
-        
-        ; =>error_invalid_arg
-        ; mov rdi, 2
-        ; mov rax, QWORD snek_error_addr as _
-        ; call rax
-        ; mov rax, 0
-        ; mov rsp, rbp
-        ; pop rbp
-        ; ret
-        
-        ; =>error_bad_cast
-        ; mov rdi, 3
-        ; mov rax, QWORD snek_error_addr as _
-        ; call rax
-        ; mov rax, 0
-        ; mov rsp, rbp
-        ; pop rbp
-        ; ret
-    );
+    // Compile error handlers once at the start using shared function
+    compile_error_handlers(&mut ops, &label_map);
     
     ops.commit().unwrap();
     
@@ -512,8 +467,7 @@ pub fn run_repl(typecheck: bool) -> io::Result<()> {
                 defines = defines.update(name.clone(), heap_offset);
                 println!("{} defined", name);
             }
-           // In repl.rs - update the ReplEntry::Expr case
-
+           
             ReplEntry::Expr(expr) => {
                 // Typecheck if enabled
                 if typecheck {
diff --git a/test/type1.s b/test/type1.s
index 271da1d..a93efb2 100644
--- a/test/type1.s
+++ b/test/type1.s
@@ -3,20 +3,90 @@ global our_code_starts_here
 extern snek_error
 extern _snek_print
 
-our_code_starts_here:
+fun_even?:
   push rbp
   mov rbp, rsp
-  mov [r15 + 0], rdi
   sub rsp, 16
-  mov rax, [r15 + 0]
+  mov rax, [rbp + 16]
+  test rax, 1
+  jne error_bad_cast
+  mov [rbp - 8], rax
+  mov rax, 0
+  cmp rax, [rbp - 8]
+  mov rax, 1
+  mov rcx, 3
+  cmovne rax, rcx
+  cmp rax, 3
+  je else_1
+  mov rax, 1
+  jmp endif_2
+else_1:
+  mov rax, [rbp + 16]
+  test rax, 1
+  jne error_bad_cast
+  mov [rbp - 8], rax
+  mov rax, 2
+  mov rcx, rax
+  or rcx, [rbp - 8]
+  test rcx, 1
+  jne error_invalid_argument
+  mov rcx, rax
+  mov rax, [rbp - 8]
+  sub rax, rcx
+  jo error_overflow
+  push rax
+  call fun_odd?
+  add rsp, 8
+endif_2:
+  mov rsp, rbp
+  pop rbp
+  ret
+fun_odd?:
+  push rbp
+  mov rbp, rsp
+  sub rsp, 16
+  mov rax, [rbp + 16]
+  test rax, 1
+  jne error_bad_cast
+  mov [rbp - 8], rax
+  mov rax, 0
+  cmp rax, [rbp - 8]
+  mov rax, 1
+  mov rcx, 3
+  cmovne rax, rcx
+  cmp rax, 3
+  je else_3
+  mov rax, 3
+  jmp endif_4
+else_3:
+  mov rax, [rbp + 16]
+  test rax, 1
+  jne error_bad_cast
   mov [rbp - 8], rax
   mov rax, 2
   mov rcx, rax
   or rcx, [rbp - 8]
   test rcx, 1
   jne error_invalid_argument
-  add rax, [rbp - 8]
+  mov rcx, rax
+  mov rax, [rbp - 8]
+  sub rax, rcx
   jo error_overflow
+  push rax
+  call fun_even?
+  add rsp, 8
+endif_4:
+  mov rsp, rbp
+  pop rbp
+  ret
+our_code_starts_here:
+  push rbp
+  mov rbp, rsp
+  mov [r15 + 0], rdi
+  mov rax, [r15 + 0]
+  push rax
+  call fun_even?
+  add rsp, 8
   mov rsp, rbp
   pop rbp
   ret
diff --git a/test/type1.snek b/test/type1.snek
index fcd8564..07073a3 100644
--- a/test/type1.snek
+++ b/test/type1.snek
@@ -1 +1,11 @@
-(+ input 1)
\ No newline at end of file
+(fun (even? n) 
+  (if (= (cast Num n) 0)
+    true
+    (odd? (- (cast Num n) 1))))
+
+(fun (odd? n)
+  (if (= (cast Num n) 0)
+    false
+    (even? (- (cast Num n) 1))))
+
+(even? input)
\ No newline at end of file
